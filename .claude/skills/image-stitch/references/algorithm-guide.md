# 图片拼接算法说明

## 1. 重复内容检测算法

### 1.1 模板匹配法

**原理**：
在两张相邻图片中，使用模板匹配算法寻找重叠区域。假设图片A在先，图片B在后，则图片A的底部应该与图片B的顶部有重叠。

**步骤**：
1. 从图片A底部提取不同高度的模板
2. 在图片B顶部搜索匹配位置
3. 使用归一化交叉相关系数（NCC）评估相似度
4. 选择相似度最高的重叠位置

**公式**：
```
NCC(I, T) = Σ(I(x,y) - μI) * (T(x,y) - μT) / √(Σ(I(x,y) - μI)² * Σ(T(x,y) - μT)²)
```

其中：
- I 是搜索区域
- T 是模板
- μ 是均值

**实现**：
```python
result = cv2.matchTemplate(search_region, template, cv2.TM_CCOEFF_NORMED)
min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
```

### 1.2 多尺度搜索

为了提高匹配精度，采用多尺度策略：
- 从最小重叠开始搜索（如50px）
- 逐步增加重叠区域（步长10px）
- 在每个尺度上计算相似度
- 选择最佳匹配

### 1.3 置信度评估

**阈值设定**：
- 默认阈值：0.8
- 高阈值（0.9+）：适用于高质量、内容稳定的截图
- 低阈值（0.7-0.8）：适用于略有变化的内容

## 2. 拼接点计算算法

### 2.1 差异最小化

在重叠区域内找到最佳拼接点，使得拼接前后的差异最小。

**步骤**：
1. 在重叠区域内滑动拼接点
2. 计算每个位置的重叠区域差异（SSD）
3. 选择差异最小的位置作为拼接点

**公式**：
```
SSD = Σ(I1(x,y) - I2(x,y))²
```

### 2.2 边缘检测优化

考虑图像边缘信息，避免在纹理复杂区域拼接：
1. 计算图像梯度
2. 优先选择梯度变化小的位置
3. 避免在文本、线条等元素上拼接

## 3. 导航栏检测算法

### 3.1 颜色方差检测

**原理**：
导航栏（状态栏、底部导航）通常颜色单一，方差较小。

**步骤**：
1. 提取顶部/底部固定高度的区域
2. 计算该区域的颜色方差
3. 如果方差低于阈值，判定为导航栏
4. 返回实际导航栏高度

**公式**：
```
Var = Σ(p(x,y) - μ)² / N
```

其中：
- p(x,y) 是像素值
- μ 是均值
- N 是像素数量

**阈值设定**：
- 方差阈值：1000（经验值）
- iOS状态栏：约44px
- iOS底部导航：约34px
- Android状态栏：约24-36px

### 3.2 固定高度假设

如果检测失败，使用默认高度：
- 顶部导航栏：44px（iOS）
- 底部导航栏：34px（iOS）

## 4. 边缘融合算法

### 4.1 加权渐变融合

**原理**：
在重叠区域内，使用加权平均将两张图片融合，权重随位置线性变化。

**步骤**：
1. 在重叠区域创建渐变权重
2. 顶部使用img1的权重逐渐减少
3. 底部使用img2的权重逐渐增加
4. 加权平均得到融合结果

**公式**：
```
I_result(x,y) = I1(x,y) * w1(x,y) + I2(x,y) * w2(x,y)
```

权重函数：
```
w1(x,y) = 1 - t
w2(x,y) = t
```

其中t是归一化位置（0-1）

### 4.2 双侧渐变

为了更好的融合效果，采用双侧渐变：
- 顶部融合区域：img1权重从1降至0.5
- 中间区域：等权重0.5
- 底部融合区域：img2权重从0.5升至1

**实现**：
```python
if i < blend_width:
    weight1 = 1.0 - i / blend_width
    weight2 = i / blend_width
elif i > overlap - blend_width:
    weight1 = (overlap - i) / blend_width
    weight2 = 1.0 - (overlap - i) / blend_width
else:
    weight1 = weight2 = 0.5
```

## 5. 算法流程图

```
开始
  ↓
加载图片
  ↓
移除导航栏？（可选）
  ↓ ├─ 是 → 检测顶部/底部导航栏
  ↓        └─ 裁剪导航栏
  ↓
自动检测重叠？（可选）
  ↓ ├─ 是 → 模板匹配找重叠
  ↓        └─ 计算最佳拼接点
  ↓
拼接图片
  ↓ ├─ 直接拼接
  ↓ └─ 或 融合拼接
  ↓
保存结果
  ↓
结束
```

## 6. 参数调优建议

### 6.1 相似度阈值（threshold）

| 场景 | 推荐值 | 说明 |
|------|--------|------|
| 高质量截图 | 0.85-0.95 | 内容稳定，匹配严格 |
| 普通截图 | 0.75-0.85 | 平衡准确性和容错 |
| 动态内容 | 0.65-0.75 | 内容可能有变化 |

### 6.2 融合宽度（blend_width）

| 场景 | 推荐值 | 说明 |
|------|--------|------|
| 纯色背景 | 20-50px | 简单融合即可 |
| 纹理背景 | 50-100px | 需要平滑过渡 |
| 复杂内容 | 100-200px | 避免明显接缝 |

### 6.3 导航栏高度

| 系统 | 顶部 | 底部 |
|------|------|------|
| iOS (iPhone) | 44px | 34px |
| iOS (iPad) | 24px | 20px |
| Android | 24-36px | 48px |
| Android (手势) | 24-36px | 8px |

## 7. 常见问题

### 7.1 拼接错位

**原因**：
- 图片顺序错误
- 重叠检测失败
- 匹配阈值过高

**解决方案**：
1. 确保图片按正确顺序命名
2. 降低相似度阈值
3. 增加截图时的重叠区域

### 7.2 拼接缝明显

**原因**：
- 融合宽度太小
- 光照变化
- 内容差异

**解决方案**：
1. 增加融合宽度（blend_width）
2. 使用渐变融合
3. 确保截图时光照一致

### 7.3 导航栏未移除

**原因**：
- 检测阈值不当
- 导航栏颜色不单一
- 自定义主题

**解决方案**：
1. 手动指定导航栏高度
2. 调整检测阈值
3. 使用固定高度参数

## 8. 性能优化

### 8.1 图像缩放

对于大尺寸图片，可以先缩小后处理：
```python
scale = 0.5
small_img = cv2.resize(img, None, fx=scale, fy=scale)
```

### 8.2 并行处理

多图片处理时可并行化：
```python
from multiprocessing import Pool
```

### 8.3 缓存中间结果

避免重复计算，缓存中间匹配结果。

## 9. 扩展方向

1. **基于特征的拼接**：使用SIFT/SURF特征点匹配
2. **内容感知融合**：根据内容类型调整融合策略
3. **自动裁剪**：检测空白区域并自动裁剪
4. **智能排序**：基于内容相似度自动排序图片
